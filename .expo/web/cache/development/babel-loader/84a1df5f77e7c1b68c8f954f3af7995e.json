{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.computeGeometry = void 0;\n\nvar react_native_1 = require(\"react-native-web/dist/index\");\n\nvar computeGeometry = function computeGeometry(contentSize, placement, fromRect, displayArea, arrowSize) {\n  var effectiveArrowSize = getArrowSize(arrowSize, placement);\n\n  switch (placement) {\n    case 'top':\n      return computeTopGeometry(displayArea, fromRect, contentSize, effectiveArrowSize);\n\n    case 'bottom':\n      return computeBottomGeometry(displayArea, fromRect, contentSize, effectiveArrowSize);\n\n    case 'start':\n      return computeStartGeometry(displayArea, fromRect, contentSize, effectiveArrowSize);\n\n    case 'end':\n      return computeEndGeometry(displayArea, fromRect, contentSize, effectiveArrowSize);\n\n    default:\n      return computeAutoGeometry(displayArea, fromRect, contentSize, effectiveArrowSize);\n  }\n};\n\nexports.computeGeometry = computeGeometry;\n\nvar getArrowSize = function getArrowSize(size, placement) {\n  if (placement === 'start' || placement === 'end') {\n    return {\n      width: size.height,\n      height: size.width\n    };\n  }\n\n  return size;\n};\n\nvar computeTopGeometry = function computeTopGeometry(displayArea, fromRect, contentSize, arrowSize) {\n  var origin = {\n    x: Math.min(displayArea.x + displayArea.width - contentSize.width, Math.max(displayArea.x, fromRect.x + (fromRect.width - contentSize.width) / 2 - (react_native_1.I18nManager.isRTL ? fromRect.width : 0))),\n    y: fromRect.y - contentSize.height - arrowSize.height\n  };\n  var anchor = {\n    x: fromRect.x + fromRect.width / 2 * (react_native_1.I18nManager.isRTL ? -1 : 1),\n    y: fromRect.y\n  };\n  return {\n    origin: origin,\n    anchor: anchor,\n    placement: 'top'\n  };\n};\n\nvar computeBottomGeometry = function computeBottomGeometry(displayArea, fromRect, contentSize, arrowSize) {\n  var origin = {\n    x: Math.min(displayArea.x + displayArea.width - contentSize.width, Math.max(displayArea.x, fromRect.x + (fromRect.width - contentSize.width) / 2 - (react_native_1.I18nManager.isRTL ? fromRect.width : 0))),\n    y: fromRect.y + fromRect.height + arrowSize.height\n  };\n  var anchor = {\n    x: fromRect.x + fromRect.width / 2 * (react_native_1.I18nManager.isRTL ? -1 : 1),\n    y: fromRect.y + fromRect.height\n  };\n  return {\n    origin: origin,\n    anchor: anchor,\n    placement: 'bottom'\n  };\n};\n\nvar computeStartGeometry = function computeStartGeometry(displayArea, fromRect, contentSize, arrowSize) {\n  var origin = {\n    x: fromRect.x - contentSize.width - arrowSize.width - (react_native_1.I18nManager.isRTL ? fromRect.width : 0),\n    y: Math.min(displayArea.y + displayArea.height - contentSize.height, Math.max(displayArea.y, fromRect.y + fromRect.height - contentSize.height))\n  };\n  var anchor = {\n    x: fromRect.x - (react_native_1.I18nManager.isRTL ? fromRect.width : 0),\n    y: fromRect.y + fromRect.height - contentSize.height / 2\n  };\n  return {\n    origin: origin,\n    anchor: anchor,\n    placement: 'start'\n  };\n};\n\nvar computeEndGeometry = function computeEndGeometry(displayArea, fromRect, contentSize, arrowSize) {\n  var origin = {\n    x: fromRect.x + fromRect.width + arrowSize.width - (react_native_1.I18nManager.isRTL ? fromRect.width : 0),\n    y: Math.min(displayArea.y + displayArea.height - contentSize.height, Math.max(displayArea.y, fromRect.y + fromRect.height - contentSize.height))\n  };\n  var anchor = {\n    x: fromRect.x + (react_native_1.I18nManager.isRTL ? 0 : fromRect.width),\n    y: fromRect.y + fromRect.height - contentSize.height / 2\n  };\n  return {\n    origin: origin,\n    anchor: anchor,\n    placement: 'end'\n  };\n};\n\nvar computeAutoGeometry = function computeAutoGeometry(displayArea, fromRect, contentSize, arrowSize) {\n  var geom = null;\n  var placements = ['start', 'end', 'top', 'bottom'];\n\n  for (var i = 0; i < 4; i += 1) {\n    var placement = placements[i];\n    geom = exports.computeGeometry(contentSize, placement, fromRect, displayArea, arrowSize);\n    var _geom = geom,\n        origin = _geom.origin;\n\n    if (origin.x >= displayArea.x && origin.x <= displayArea.x + displayArea.width - contentSize.width && origin.y >= displayArea.y && origin.y <= displayArea.y + displayArea.height - contentSize.height) {\n      break;\n    }\n  }\n\n  return geom;\n};","map":{"version":3,"sources":["../src/PopoverGeometry.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.computeGeometry = void 0;\nconst react_native_1 = require(\"react-native\");\nconst computeGeometry = (contentSize, placement, fromRect, displayArea, arrowSize) => {\n    const effectiveArrowSize = getArrowSize(arrowSize, placement);\n    switch (placement) {\n        case 'top':\n            return computeTopGeometry(displayArea, fromRect, contentSize, effectiveArrowSize);\n        case 'bottom':\n            return computeBottomGeometry(displayArea, fromRect, contentSize, effectiveArrowSize);\n        case 'start':\n            return computeStartGeometry(displayArea, fromRect, contentSize, effectiveArrowSize);\n        case 'end':\n            return computeEndGeometry(displayArea, fromRect, contentSize, effectiveArrowSize);\n        default:\n            return computeAutoGeometry(displayArea, fromRect, contentSize, effectiveArrowSize);\n    }\n};\nexports.computeGeometry = computeGeometry;\nconst getArrowSize = (size, placement) => {\n    if (placement === 'start' || placement === 'end') {\n        return { width: size.height, height: size.width };\n    }\n    return size;\n};\nconst computeTopGeometry = (displayArea, fromRect, contentSize, arrowSize) => {\n    const origin = {\n        x: Math.min(displayArea.x + displayArea.width - contentSize.width, Math.max(displayArea.x, fromRect.x +\n            (fromRect.width - contentSize.width) / 2 -\n            (react_native_1.I18nManager.isRTL ? fromRect.width : 0))),\n        y: fromRect.y - contentSize.height - arrowSize.height,\n    };\n    const anchor = {\n        x: fromRect.x + (fromRect.width / 2) * (react_native_1.I18nManager.isRTL ? -1 : 1),\n        y: fromRect.y,\n    };\n    return { origin, anchor, placement: 'top' };\n};\nconst computeBottomGeometry = (displayArea, fromRect, contentSize, arrowSize) => {\n    const origin = {\n        x: Math.min(displayArea.x + displayArea.width - contentSize.width, Math.max(displayArea.x, fromRect.x +\n            (fromRect.width - contentSize.width) / 2 -\n            (react_native_1.I18nManager.isRTL ? fromRect.width : 0))),\n        y: fromRect.y + fromRect.height + arrowSize.height,\n    };\n    const anchor = {\n        x: fromRect.x + (fromRect.width / 2) * (react_native_1.I18nManager.isRTL ? -1 : 1),\n        y: fromRect.y + fromRect.height,\n    };\n    return { origin, anchor, placement: 'bottom' };\n};\nconst computeStartGeometry = (displayArea, fromRect, contentSize, arrowSize) => {\n    const origin = {\n        x: fromRect.x -\n            contentSize.width -\n            arrowSize.width -\n            (react_native_1.I18nManager.isRTL ? fromRect.width : 0),\n        y: Math.min(displayArea.y + displayArea.height - contentSize.height, Math.max(displayArea.y, fromRect.y + fromRect.height - contentSize.height)),\n    };\n    const anchor = {\n        x: fromRect.x - (react_native_1.I18nManager.isRTL ? fromRect.width : 0),\n        y: fromRect.y + fromRect.height - contentSize.height / 2,\n    };\n    return { origin, anchor, placement: 'start' };\n};\nconst computeEndGeometry = (displayArea, fromRect, contentSize, arrowSize) => {\n    const origin = {\n        x: fromRect.x +\n            fromRect.width +\n            arrowSize.width -\n            (react_native_1.I18nManager.isRTL ? fromRect.width : 0),\n        y: Math.min(displayArea.y + displayArea.height - contentSize.height, Math.max(displayArea.y, fromRect.y + fromRect.height - contentSize.height)),\n    };\n    const anchor = {\n        x: fromRect.x + (react_native_1.I18nManager.isRTL ? 0 : fromRect.width),\n        y: fromRect.y + fromRect.height - contentSize.height / 2,\n    };\n    return { origin, anchor, placement: 'end' };\n};\nconst computeAutoGeometry = (displayArea, fromRect, contentSize, arrowSize) => {\n    let geom = null;\n    const placements = ['start', 'end', 'top', 'bottom'];\n    for (let i = 0; i < 4; i += 1) {\n        const placement = placements[i];\n        geom = exports.computeGeometry(contentSize, placement, fromRect, displayArea, arrowSize);\n        const { origin } = geom;\n        if (origin.x >= displayArea.x &&\n            origin.x <= displayArea.x + displayArea.width - contentSize.width &&\n            origin.y >= displayArea.y &&\n            origin.y <= displayArea.y + displayArea.height - contentSize.height) {\n            break;\n        }\n    }\n    return geom;\n};\n//# sourceMappingURL=PopoverGeometry.js.map"]},"metadata":{},"sourceType":"script"}